diff --git a/node_modules/@y/websocket-server/src/utils.js b/node_modules/@y/websocket-server/src/utils.js
index d624c5a..0364c26 100644
--- a/node_modules/@y/websocket-server/src/utils.js
+++ b/node_modules/@y/websocket-server/src/utils.js
@@ -23,28 +23,34 @@ const wsReadyStateClosed = 3 // eslint-disable-line
 
 // disable gc when using snapshots!
 const gcEnabled = process.env.GC !== 'false' && process.env.GC !== '0'
-const persistenceDir = process.env.YPERSISTENCE
+// Use environment variable or default to './y-leveldb-database'
+const persistenceDir = process.env.YPERSISTENCE || './y-leveldb-database'
 /**
  * @type {{bindState: function(string,WSSharedDoc):void, writeState:function(string,WSSharedDoc):Promise<any>, provider: any}|null}
  */
 let persistence = null
-if (typeof persistenceDir === 'string') {
-  console.info('Persisting documents to "' + persistenceDir + '"')
-  // @ts-ignore
-  const ldb = new LeveldbPersistence(persistenceDir)
-  persistence = {
-    provider: ldb,
-    bindState: async (docName, ydoc) => {
-      const persistedYdoc = await ldb.getYDoc(docName)
-      const newUpdates = Y.encodeStateAsUpdate(ydoc)
-      ldb.storeUpdate(docName, newUpdates)
-      Y.applyUpdate(ydoc, Y.encodeStateAsUpdate(persistedYdoc))
-      ydoc.on('update', update => {
-        ldb.storeUpdate(docName, update)
-      })
-    },
-    writeState: async (_docName, _ydoc) => {}
-  }
+console.info('Persisting documents to "' + persistenceDir + '"')
+// @ts-ignore
+const ldb = new LeveldbPersistence(persistenceDir)
+persistence = {
+  provider: ldb,
+  bindState: async (docName, ydoc) => {
+    console.log(`ðŸ“‚ [LevelDB] Loading document: "${docName}"`)
+    const persistedYdoc = await ldb.getYDoc(docName)
+    const persistedState = Y.encodeStateAsUpdate(persistedYdoc)
+    console.log(`ðŸ“¥ [LevelDB] Retrieved ${persistedState.length} bytes for room: "${docName}"`)
+    
+    const newUpdates = Y.encodeStateAsUpdate(ydoc)
+    ldb.storeUpdate(docName, newUpdates)
+    Y.applyUpdate(ydoc, Y.encodeStateAsUpdate(persistedYdoc))
+    console.log(`âœ… [LevelDB] Document "${docName}" loaded and applied`)
+    
+    ydoc.on('update', update => {
+      console.log(`ðŸ’¾ [LevelDB] Saving update (${update.length} bytes) for room: "${docName}"`)
+      ldb.storeUpdate(docName, update)
+    })
+  },
+  writeState: async (_docName, _ydoc) => {}
 }
 
 /**
@@ -212,8 +218,10 @@ const closeConn = (doc, conn) => {
     // @ts-ignore
     const controlledIds = doc.conns.get(conn)
     doc.conns.delete(conn)
+    console.log(`ðŸ‘‹ [WebSocket] Client disconnected from room: "${doc.name}" (Remaining clients: ${doc.conns.size})`)
     awarenessProtocol.removeAwarenessStates(doc.awareness, Array.from(controlledIds), null)
     if (doc.conns.size === 0 && persistence !== null) {
+      console.log(`ðŸ”’ [Room] No clients left in room: "${doc.name}" - Cleaning up`)
       // if persisted, we store state and destroy ydocument
       persistence.writeState(doc.name, doc).then(() => {
         doc.destroy()
@@ -249,9 +257,12 @@ const pingTimeout = 30000
  */
 export const setupWSConnection = (conn, req, { docName = (req.url || '').slice(1).split('?')[0], gc = true } = {}) => {
   conn.binaryType = 'arraybuffer'
+  console.log(`ðŸ”Œ [WebSocket] New connection to room: "${docName}"`)
+  console.log(`ðŸ‘¥ [WebSocket] Active connections in room "${docName}": ${docs.get(docName)?.conns.size || 0}`)
   // get doc, initialize if it does not exist yet
   const doc = getYDoc(docName, gc)
   doc.conns.set(conn, new Set())
+  console.log(`âœ… [WebSocket] Client connected to room: "${docName}" (Total clients: ${doc.conns.size})`)
   // listen and reply to events
   conn.on('message', /** @param {ArrayBuffer} message */ message => messageListener(conn, doc, new Uint8Array(message)))
 
